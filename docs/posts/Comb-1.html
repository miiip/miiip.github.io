<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.8.25">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Mihail Plesa">
<meta name="dcterms.date" content="2026-01-07">

<title>Algorithmic Foundations: Deep Dive into Combinatorial Analysis (Part 1) ‚Äì Blog</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../site_libs/clipboard/clipboard.min.js"></script>
<script src="../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../site_libs/quarto-search/fuse.min.js"></script>
<script src="../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../">
<script src="../site_libs/quarto-html/quarto.js" type="module"></script>
<script src="../site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="../site_libs/quarto-html/axe/axe-check.js" type="module"></script>
<script src="../site_libs/quarto-html/popper.min.js"></script>
<script src="../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../site_libs/quarto-html/anchor.min.js"></script>
<link href="../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting-7b89279ff1a6dce999919e0e67d4d9ec.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../site_libs/bootstrap/bootstrap-5b4ad623e5705c0698d39aec6f10cf02.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<link href="../site_libs/quarto-contrib/academicons-1.9.4/all.css" rel="stylesheet">
<link href="../site_libs/quarto-contrib/academicons-1.9.4/size.css" rel="stylesheet">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN" && texText && texText.data) {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="../styles.css">
</head>

<body class="nav-fixed fullcontent quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top quarto-banner">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a href="../index.html" class="navbar-brand navbar-brand-logo">
    </a>
    <a class="navbar-brand" href="../index.html">
    <span class="navbar-title">Blog</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../presentations.html"> 
<span class="menu-text">Presentations</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../publications.html"> 
<span class="menu-text">Publications</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../about.html"> 
<span class="menu-text">About</span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://www.linkedin.com/in/mihail-iulian-plesa-ab7838249/" target="_blank"> <i class="bi bi-linkedin" role="img" aria-label="LinkedIn">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="https://scholar.google.com/citations?user=dvlBs70AAAAJ&amp;hl=en" target="_blank"> 
<span class="menu-text"><i class="ai  ai-google-scholar ai-lg" aria-label="google-scholar"></i></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="../index.xml"> <i class="bi bi-rss" role="img" aria-label="RSS feed">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <h1 class="title">Algorithmic Foundations: Deep Dive into Combinatorial Analysis (Part 1)</h1>
                                <div class="quarto-categories">
                <div class="quarto-category">foundations</div>
              </div>
                  </div>
  </div>
    
  
  <div class="quarto-title-meta">

      <div>
      <div class="quarto-title-meta-heading">Author</div>
      <div class="quarto-title-meta-contents">
               <p>Mihail Plesa </p>
            </div>
    </div>
      
      <div>
      <div class="quarto-title-meta-heading">Published</div>
      <div class="quarto-title-meta-contents">
        <p class="date">January 7, 2026</p>
      </div>
    </div>
    
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    
<!-- main -->
<main class="content quarto-banner-title-block" id="quarto-document-content">





<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="book.jpg" class="img-fluid quarto-figure quarto-figure-center figure-img" style="width:40.0%"></p>
</figure>
</div>
<section id="a-holiday-dive-into-combinatorics" class="level2">
<h2 class="anchored" data-anchor-id="a-holiday-dive-into-combinatorics">A Holiday Dive into Combinatorics</h2>
<p>With a bit of free time on my hands during the holiday break, I decided to embark on a mathematical adventure into the foundations of combinatorial algorithms. And what better companion for this journey than the classic text, A Walk Through Combinatorics and Graph Theory by Mikl√≥s B√≥na?</p>
<p>I‚Äôve made my way through the first few chapters, and in this post, I‚Äôll share my take on them‚Äîpresented with a twist. While the book itself is excellent, it can sometimes lean toward the formal side, making the underlying intuition a bit elusive. Nevertheless, its clear structure and step-by-step introduction of concepts make it a fantastic resource for beginners.</p>
<p>So, if you‚Äôre ready to explore the world of combinatorics from a fresh perspective, join me on this walk! I hope you enjoy the journey as much as I did. üòä</p>
</section>
<section id="how-many-ways-can-mathematicians-line-up-for-coffee" class="level2">
<h2 class="anchored" data-anchor-id="how-many-ways-can-mathematicians-line-up-for-coffee">How Many Ways Can Mathematicians Line Up for Coffee?</h2>
<p>Let us commence our mathematical adventure with a deceptively simple question: Given <span class="math inline">\(n\)</span> individuals, in how many distinct ways can we arrange them in a single line? Imagine, if you will, a group of eager volunteers‚Äîperhaps mathematicians at a conference‚Äîawaiting their turn to stand in line for coffee.</p>
<p>For the coveted first spot in the line, we have <span class="math inline">\(n\)</span> enthusiastic candidates. Once that position is filled, only <span class="math inline">\(n-1\)</span> hopefuls remain for the second spot, as one lucky individual is already sipping their metaphorical coffee at the front. This process continues, with each subsequent spot having one fewer option, until the final position, which is reserved for the last remaining person (who, let‚Äôs be honest, probably didn‚Äôt want to stand in line anyway).</p>
<p>Multiplying these choices together, we obtain the grand total of possible arrangements:</p>
<p><span class="math display">\[ n \times (n-1) \times (n-2) \times \cdots \times 2 \times 1 \]</span></p>
<p>This mathematical mouthful is succinctly denoted as <span class="math inline">\(n!\)</span> (read as ‚Äún factorial‚Äù). In other words, <span class="math inline">\(n!\)</span> is the number of ways to organize <span class="math inline">\(n\)</span> unique individuals into a line‚Äîno coffee required, but a dash of combinatorial curiosity is highly recommended!</p>
<p>By convention, we define <span class="math inline">\(0! = 1\)</span>. At first glance, this might seem as peculiar as decaf coffee at a mathematicians‚Äô conference, but let‚Äôs explore why this makes perfect sense.</p>
<p>Imagine we have two coffee machines. In front of the first machine, there are <span class="math inline">\(n\)</span> mathematicians eagerly awaiting their caffeine fix, while <span class="math inline">\(m\)</span> mathematicians queue up at the second machine. The question arises: in how many ways can we form two separate lines, one for each machine? The answer is straightforward‚Äîthere are <span class="math inline">\(n!\)</span> possible arrangements for the first line and <span class="math inline">\(m!\)</span> for the second, so the total number of ways to organize both lines is:</p>
<p><span class="math display">\[ n! \times m! \]</span></p>
<p>Now, let‚Äôs introduce a plot twist. Suppose all <span class="math inline">\(m\)</span> mathematicians at the second coffee machine suddenly decide to abandon their quest for coffee and leave the line. The second line is now empty, but our original question remains: in how many ways can we form two lines? For the first machine, we still have <span class="math inline">\(n!\)</span> possible arrangements. For the second, with zero mathematicians, how many ways can we arrange an empty line? By our earlier formula, the answer must be:</p>
<p><span class="math display">\[ n! \times 0! \]</span></p>
<p>But logically, there is exactly one way to arrange nothing at all‚Äîby doing nothing! Thus, for our formula to remain consistent, we must have <span class="math inline">\(0! = 1\)</span>. It‚Äôs a mathematical nod to the power of nothingness: even an empty line counts as one arrangement!</p>
</section>
<section id="from-lineups-to-teams-counting-unique-combinations" class="level2">
<h2 class="anchored" data-anchor-id="from-lineups-to-teams-counting-unique-combinations">From Lineups to Teams: Counting Unique Combinations</h2>
<p>Now, let‚Äôs up the ante: suppose we wish to divide our <span class="math inline">\(n\)</span> mathematicians into <span class="math inline">\(t\)</span> disjoint teams. The first team will have <span class="math inline">\(a_1\)</span> members, the second team <span class="math inline">\(a_2\)</span> members, and so on, until the <span class="math inline">\(t\)</span>-th team, which has <span class="math inline">\(a_t\)</span> members. Since no mathematician is allowed to clone themselves (yet), each person can only be in one team, so we must have:</p>
<p><span class="math display">\[ a_1 + a_2 + \cdots + a_t = n \]</span></p>
<p>A natural question arises: in how many ways can we organize our <span class="math inline">\(n\)</span> mathematicians into these <span class="math inline">\(t\)</span> teams?</p>
<p>One intuitive approach is to line up all the mathematicians in some order and then assign the first <span class="math inline">\(a_1\)</span> people to the first team, the next <span class="math inline">\(a_2\)</span> to the second team, and so on. Since there are <span class="math inline">\(n!\)</span> ways to arrange <span class="math inline">\(n\)</span> people in a line, it might be tempting to declare that there are <span class="math inline">\(n!\)</span> ways to form the teams.</p>
<p>However, there‚Äôs a subtle catch: within each team, the order of the members doesn‚Äôt matter. The team consisting of Alice, Bob, and Eve is indistinguishable from the team of Bob, Eve, and Alice‚Äîunless, of course, you‚Äôre keeping score of who gets their coffee first.</p>
<p>This means that our <span class="math inline">\(n!\)</span> possible lineups will generate many duplicate team configurations. Why? Because within each team, the order of the members doesn‚Äôt matter. For example, if the first team has <span class="math inline">\(a_1\)</span> members, any of the <span class="math inline">\(a_1!\)</span> ways to arrange those people among themselves will result in the exact same team. The same logic applies to the second team: there are <span class="math inline">\(a_2!\)</span> ways to rearrange its members without changing the team itself. This continues for each team, all the way up to the <span class="math inline">\(t\)</span>-th team, which can be internally rearranged in <span class="math inline">\(a_t!\)</span> ways.</p>
<p>To find the total number of duplicate arrangements, we multiply these possibilities together:</p>
<p><span class="math display">\[ a_1! \times a_2! \times \cdots \times a_t! \]</span></p>
<p>This product represents all the ways we can shuffle the members within each team, across all teams, without actually creating a new team configuration. So, to count only the truly distinct ways to form the teams, we divide the total number of lineups, <span class="math inline">\(n!\)</span>, by this product:</p>
<p><span class="math display">\[ \frac{n!}{a_1! \times a_2! \times \cdots \times a_t!} \]</span></p>
<p>In other words, we‚Äôre correcting for all the ‚Äúinternal shuffling‚Äù that doesn‚Äôt change the teams themselves.</p>
</section>
<section id="choosing-subsets-when-order-doesnt-matter" class="level2">
<h2 class="anchored" data-anchor-id="choosing-subsets-when-order-doesnt-matter">Choosing Subsets: When Order Doesn‚Äôt Matter</h2>
<p>Now, let‚Äôs zoom in on a particularly famous case of our team-forming formula: the binomial coefficient. Some of you may already feel a sense of d√©j√† vu!</p>
<p>Suppose we set the number of teams to <span class="math inline">\(t = 2\)</span>, and let the first team have <span class="math inline">\(k\)</span> members (that is, <span class="math inline">\(a_1 = k\)</span>). By necessity, the second team will have <span class="math inline">\(n - k\)</span> members, since <span class="math inline">\(a_2 = n - k\)</span>. Plugging these values into our earlier formula, we get:</p>
<p><span class="math display">\[ \frac{n!}{k! (n-k)!} \]</span></p>
<p>This expression is known as the binomial coefficient, and is commonly denoted as <span class="math inline">\(\binom{n}{k}\)</span>. It represents the number of ways to choose a subset of <span class="math inline">\(k\)</span> individuals from a set of <span class="math inline">\(n\)</span>‚Äîor, in less formal terms, the number of ways to assemble a team of <span class="math inline">\(k\)</span> mathematicians from a larger group of <span class="math inline">\(n\)</span>.</p>
<p>But why do we call this a ‚Äúset‚Äù? Because, in a set, the order of the elements doesn‚Äôt matter‚Äîjust as in our team-forming scenario above. Whether Alice, Bob, and Eve are chosen in that order or in any other, it‚Äôs the same team. So, <span class="math inline">\(\binom{n}{k}\)</span> counts the number of unordered groups of <span class="math inline">\(k\)</span> people you can select from <span class="math inline">\(n\)</span> candidates‚Äîa mathematical staple as classic as coffee at a conference!</p>
</section>
<section id="the-binomial-theorem-vowels-and-the-magic-of-counting-twice" class="level2">
<h2 class="anchored" data-anchor-id="the-binomial-theorem-vowels-and-the-magic-of-counting-twice">The Binomial Theorem, Vowels, and the Magic of Counting Twice</h2>
<p>Now, for my favorite part of this post: story proofs! Throughout our mathematical education‚Äîwhether in high school, undergrad, or even grad school‚Äîwe‚Äôre often presented with proofs that are formal, symbol-heavy, and, let‚Äôs be honest, sometimes a bit intimidating. But here‚Äôs the secret: you don‚Äôt always need a blizzard of symbols to make a proof rigorous. Sometimes, a good story is all you need.</p>
<p>This idea is beautifully championed by Prof.&nbsp;Joe Blitzstein in his legendary Stat 110 course at Harvard. Instead of drowning in algebraic notation, let‚Äôs prove a classic result with a story. Consider the famous Binomial Theorem:</p>
<p><span class="math display">\[ (x + y)^n = \sum_{k=0}^n \binom{n}{k} x^k y^{n-k} \]</span></p>
<p>Don‚Äôt ask me for a ‚Äústandard‚Äù proof‚ÄîI‚Äôm not sure I know one! But I can offer a proof that‚Äôs intuitive, makes perfect sense, and is as solid as any formal argument.</p>
<p>The Story:</p>
<p>Suppose you have a vocabulary of size <span class="math inline">\(v\)</span>. How many <span class="math inline">\(n\)</span>-letter words can you form using this vocabulary? For each letter in the word, you have <span class="math inline">\(v\)</span> choices, so the total number of possible words is simply <span class="math inline">\(v^n\)</span>.</p>
<p>Now, let‚Äôs count the same thing in a more nuanced way. Suppose your vocabulary consists of <span class="math inline">\(x\)</span> vowels and <span class="math inline">\(y\)</span> consonants, so <span class="math inline">\(x + y = v\)</span>. Let‚Äôs ask: how many <span class="math inline">\(n\)</span>-letter words have exactly <span class="math inline">\(k\)</span> vowels, and those vowels are placed at specific positions <span class="math inline">\(i_1, i_2, \ldots, i_k\)</span>?</p>
<p>For each of these <span class="math inline">\(k\)</span> positions, you have <span class="math inline">\(x\)</span> choices (any vowel), so there are <span class="math inline">\(x^k\)</span> ways to assign vowels to those spots. For the remaining <span class="math inline">\(n-k\)</span> positions, each can be filled with any of the <span class="math inline">\(y\)</span> consonants, giving <span class="math inline">\(y^{n-k}\)</span> possibilities. So, for a fixed set of <span class="math inline">\(k\)</span> positions for the vowels, there are <span class="math inline">\(x^k y^{n-k}\)</span> possible words.</p>
<p>But how many ways can we choose which <span class="math inline">\(k\)</span> positions will be occupied by vowels? That‚Äôs exactly <span class="math inline">\(\binom{n}{k}\)</span>, the number of ways to choose <span class="math inline">\(k\)</span> positions out of <span class="math inline">\(n\)</span>.</p>
<p>Therefore, the total number of <span class="math inline">\(n\)</span>-letter words with exactly <span class="math inline">\(k\)</span> vowels (regardless of where they appear) is:</p>
<p><span class="math display">\[ \binom{n}{k} x^k y^{n-k} \]</span></p>
<p>To find the total number of <span class="math inline">\(n\)</span>-letter words (with any number of vowels from <span class="math inline">\(0\)</span> to <span class="math inline">\(n\)</span>), we sum over all possible values of <span class="math inline">\(k\)</span>:</p>
<p><span class="math display">\[ \sum_{k=0}^n \binom{n}{k} x^k y^{n-k} \]</span></p>
<p>But we already know, from our earlier calculation, that the total number of <span class="math inline">\(n\)</span>-letter words is <span class="math inline">\(v^n\)</span>, where <span class="math inline">\(v = x + y\)</span>. So, by counting the same thing in two different ways, we arrive at:</p>
<p><span class="math display">\[ (x + y)^n = \sum_{k=0}^n \binom{n}{k} x^k y^{n-k} \]</span></p>
<p>And there you have it‚Äîa proof that‚Äôs as satisfying as finding the last piece of a mathematical puzzle, all thanks to a story about vowels, consonants, and the magic of counting!</p>
</section>
<section id="counting-is-just-the-beginning" class="level2">
<h2 class="anchored" data-anchor-id="counting-is-just-the-beginning">Counting is Just the Beginning</h2>
<p>This post covered the first part of the book, focusing on the art and science of counting. But don‚Äôt put away your mathematical curiosity just yet‚Äîthere‚Äôs much more to explore! Stay tuned for the next chapters üòä</p>


</section>

</main> <!-- /main -->
<script src="https://giscus.app/client.js" data-repo="miiip/miiip.github.io" data-repo-id="YOUR_REPO_ID" data-category="Comments" data-category-id="YOUR_CATEGORY_ID" data-mapping="pathname" data-strict="0" data-reactions-enabled="1" data-emit-metadata="0" data-input-position="bottom" data-theme="light" data-lang="en" crossorigin="anonymous" async="">
</script>
<noscript>Please enable JavaScript to view the comments.</noscript>
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "Óßã";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
      const outerScaffold = trigger.parentElement.cloneNode(true);
      const codeEl = outerScaffold.querySelector('code');
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp("https:\/\/miiip\.github\.io");
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>